{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"verilog\", function (config, parserConfig) {\n    var indentUnit = config.indentUnit,\n        statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,\n        dontAlignCalls = parserConfig.dontAlignCalls,\n        // compilerDirectivesUseRegularIndentation - If set, Compiler directive\n    // indentation follows the same rules as everything else. Otherwise if\n    // false, compiler directives will track their own indentation.\n    // For example, `ifdef nested inside another `ifndef will be indented,\n    // but a `ifdef inside a function block may not be indented.\n    compilerDirectivesUseRegularIndentation = parserConfig.compilerDirectivesUseRegularIndentation,\n        noIndentKeywords = parserConfig.noIndentKeywords || [],\n        multiLineStrings = parserConfig.multiLineStrings,\n        hooks = parserConfig.hooks || {};\n\n    function words(str) {\n      var obj = {},\n          words = str.split(\" \");\n\n      for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n\n      return obj;\n    }\n    /**\n     * Keywords from IEEE 1800-2012\n     */\n\n\n    var keywords = words(\"accept_on alias always always_comb always_ff always_latch and assert assign assume automatic before begin bind \" + \"bins binsof bit break buf bufif0 bufif1 byte case casex casez cell chandle checker class clocking cmos config \" + \"const constraint context continue cover covergroup coverpoint cross deassign default defparam design disable \" + \"dist do edge else end endcase endchecker endclass endclocking endconfig endfunction endgenerate endgroup \" + \"endinterface endmodule endpackage endprimitive endprogram endproperty endspecify endsequence endtable endtask \" + \"enum event eventually expect export extends extern final first_match for force foreach forever fork forkjoin \" + \"function generate genvar global highz0 highz1 if iff ifnone ignore_bins illegal_bins implements implies import \" + \"incdir include initial inout input inside instance int integer interconnect interface intersect join join_any \" + \"join_none large let liblist library local localparam logic longint macromodule matches medium modport module \" + \"nand negedge nettype new nexttime nmos nor noshowcancelled not notif0 notif1 null or output package packed \" + \"parameter pmos posedge primitive priority program property protected pull0 pull1 pulldown pullup \" + \"pulsestyle_ondetect pulsestyle_onevent pure rand randc randcase randsequence rcmos real realtime ref reg \" + \"reject_on release repeat restrict return rnmos rpmos rtran rtranif0 rtranif1 s_always s_eventually s_nexttime \" + \"s_until s_until_with scalared sequence shortint shortreal showcancelled signed small soft solve specify \" + \"specparam static string strong strong0 strong1 struct super supply0 supply1 sync_accept_on sync_reject_on \" + \"table tagged task this throughout time timeprecision timeunit tran tranif0 tranif1 tri tri0 tri1 triand trior \" + \"trireg type typedef union unique unique0 unsigned until until_with untyped use uwire var vectored virtual void \" + \"wait wait_order wand weak weak0 weak1 while wildcard wire with within wor xnor xor\");\n    /** Operators from IEEE 1800-2012\n       unary_operator ::=\n         + | - | ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n       binary_operator ::=\n         + | - | * | / | % | == | != | === | !== | ==? | !=? | && | || | **\n         | < | <= | > | >= | & | | | ^ | ^~ | ~^ | >> | << | >>> | <<<\n         | -> | <->\n       inc_or_dec_operator ::= ++ | --\n       unary_module_path_operator ::=\n         ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n       binary_module_path_operator ::=\n         == | != | && | || | & | | | ^ | ^~ | ~^\n    */\n\n    var isOperatorChar = /[\\+\\-\\*\\/!~&|^%=?:<>]/;\n    var isBracketChar = /[\\[\\]{}()]/;\n    var unsignedNumber = /\\d[0-9_]*/;\n    var decimalLiteral = /\\d*\\s*'s?d\\s*\\d[0-9_]*/i;\n    var binaryLiteral = /\\d*\\s*'s?b\\s*[xz01][xz01_]*/i;\n    var octLiteral = /\\d*\\s*'s?o\\s*[xz0-7][xz0-7_]*/i;\n    var hexLiteral = /\\d*\\s*'s?h\\s*[0-9a-fxz?][0-9a-fxz?_]*/i;\n    var realLiteral = /(\\d[\\d_]*(\\.\\d[\\d_]*)?E-?[\\d_]+)|(\\d[\\d_]*\\.\\d[\\d_]*)/i;\n    var closingBracketOrWord = /^((`?\\w+)|[)}\\]])/;\n    var closingBracket = /[)}\\]]/;\n    var compilerDirectiveRegex = new RegExp(\"^(`(?:ifdef|ifndef|elsif|else|endif|undef|undefineall|define|include|begin_keywords|celldefine|default|\" + \"nettype|end_keywords|endcelldefine|line|nounconnected_drive|pragma|resetall|timescale|unconnected_drive))\\\\b\");\n    var compilerDirectiveBeginRegex = /^(`(?:ifdef|ifndef|elsif|else))\\b/;\n    var compilerDirectiveEndRegex = /^(`(?:elsif|else|endif))\\b/;\n    var curPunc;\n    var curKeyword; // Block openings which are closed by a matching keyword in the form of (\"end\" + keyword)\n    // E.g. \"task\" => \"endtask\"\n\n    var blockKeywords = words(\"case checker class clocking config function generate interface module package \" + \"primitive program property specify sequence table task\"); // Opening/closing pairs\n\n    var openClose = {};\n\n    for (var keyword in blockKeywords) {\n      openClose[keyword] = \"end\" + keyword;\n    }\n\n    openClose[\"begin\"] = \"end\";\n    openClose[\"casex\"] = \"endcase\";\n    openClose[\"casez\"] = \"endcase\";\n    openClose[\"do\"] = \"while\";\n    openClose[\"fork\"] = \"join;join_any;join_none\";\n    openClose[\"covergroup\"] = \"endgroup\";\n    openClose[\"macro_begin\"] = \"macro_end\";\n\n    for (var i in noIndentKeywords) {\n      var keyword = noIndentKeywords[i];\n\n      if (openClose[keyword]) {\n        openClose[keyword] = undefined;\n      }\n    } // Keywords which open statements that are ended with a semi-colon\n\n\n    var statementKeywords = words(\"always always_comb always_ff always_latch assert assign assume else export for foreach forever if import initial repeat while extern typedef\");\n\n    function tokenBase(stream, state) {\n      var ch = stream.peek(),\n          style;\n      if (hooks[ch] && (style = hooks[ch](stream, state)) != false) return style;\n      if (hooks.tokenBase && (style = hooks.tokenBase(stream, state)) != false) return style;\n\n      if (/[,;:\\.]/.test(ch)) {\n        curPunc = stream.next();\n        return null;\n      }\n\n      if (isBracketChar.test(ch)) {\n        curPunc = stream.next();\n        return \"bracket\";\n      } // Macros (tick-defines)\n\n\n      if (ch == '`') {\n        stream.next();\n\n        if (stream.eatWhile(/[\\w\\$_]/)) {\n          var cur = stream.current();\n          curKeyword = cur; // Macros that end in _begin, are start of block and end with _end\n\n          if (cur.startsWith(\"`uvm_\") && cur.endsWith(\"_begin\")) {\n            var keywordClose = curKeyword.substr(0, curKeyword.length - 5) + \"end\";\n            openClose[cur] = keywordClose;\n            curPunc = \"newblock\";\n          } else {\n            stream.eatSpace();\n\n            if (stream.peek() == '(') {\n              // Check if this is a block\n              curPunc = \"newmacro\";\n            }\n\n            var withSpace = stream.current(); // Move the stream back before the spaces\n\n            stream.backUp(withSpace.length - cur.length);\n          }\n\n          return \"def\";\n        } else {\n          return null;\n        }\n      } // System calls\n\n\n      if (ch == '$') {\n        stream.next();\n\n        if (stream.eatWhile(/[\\w\\$_]/)) {\n          return \"meta\";\n        } else {\n          return null;\n        }\n      } // Time literals\n\n\n      if (ch == '#') {\n        stream.next();\n        stream.eatWhile(/[\\d_.]/);\n        return \"def\";\n      } // Event\n\n\n      if (ch == '@') {\n        stream.next();\n        stream.eatWhile(/[@]/);\n        return \"def\";\n      } // Strings\n\n\n      if (ch == '\"') {\n        stream.next();\n        state.tokenize = tokenString(ch);\n        return state.tokenize(stream, state);\n      } // Comments\n\n\n      if (ch == \"/\") {\n        stream.next();\n\n        if (stream.eat(\"*\")) {\n          state.tokenize = tokenComment;\n          return tokenComment(stream, state);\n        }\n\n        if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return \"comment\";\n        }\n\n        stream.backUp(1);\n      } // Numeric literals\n\n\n      if (stream.match(realLiteral) || stream.match(decimalLiteral) || stream.match(binaryLiteral) || stream.match(octLiteral) || stream.match(hexLiteral) || stream.match(unsignedNumber) || stream.match(realLiteral)) {\n        return \"number\";\n      } // Operators\n\n\n      if (stream.eatWhile(isOperatorChar)) {\n        curPunc = stream.current();\n        return \"meta\";\n      } // Keywords / plain variables\n\n\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        var cur = stream.current();\n\n        if (keywords[cur]) {\n          if (openClose[cur]) {\n            curPunc = \"newblock\";\n\n            if (cur === \"fork\") {\n              // Fork can be a statement instead of block in cases of:\n              // \"disable fork;\" and \"wait fork;\" (trailing semicolon)\n              stream.eatSpace();\n\n              if (stream.peek() == ';') {\n                curPunc = \"newstatement\";\n              }\n\n              stream.backUp(stream.current().length - cur.length);\n            }\n          }\n\n          if (statementKeywords[cur]) {\n            curPunc = \"newstatement\";\n          }\n\n          curKeyword = cur;\n          return \"keyword\";\n        }\n\n        return \"variable\";\n      }\n\n      stream.next();\n      return null;\n    }\n\n    function tokenString(quote) {\n      return function (stream, state) {\n        var escaped = false,\n            next,\n            end = false;\n\n        while ((next = stream.next()) != null) {\n          if (next == quote && !escaped) {\n            end = true;\n            break;\n          }\n\n          escaped = !escaped && next == \"\\\\\";\n        }\n\n        if (end || !(escaped || multiLineStrings)) state.tokenize = tokenBase;\n        return \"string\";\n      };\n    }\n\n    function tokenComment(stream, state) {\n      var maybeEnd = false,\n          ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"/\" && maybeEnd) {\n          state.tokenize = tokenBase;\n          break;\n        }\n\n        maybeEnd = ch == \"*\";\n      }\n\n      return \"comment\";\n    }\n\n    function Context(indented, column, type, scopekind, align, prev) {\n      this.indented = indented;\n      this.column = column;\n      this.type = type;\n      this.scopekind = scopekind;\n      this.align = align;\n      this.prev = prev;\n    }\n\n    function pushContext(state, col, type, scopekind) {\n      var indent = state.indented;\n      var c = new Context(indent, col, type, scopekind ? scopekind : \"\", null, state.context);\n      return state.context = c;\n    }\n\n    function popContext(state) {\n      var t = state.context.type;\n\n      if (t == \")\" || t == \"]\" || t == \"}\") {\n        state.indented = state.context.indented;\n      }\n\n      return state.context = state.context.prev;\n    }\n\n    function isClosing(text, contextClosing) {\n      if (text == contextClosing) {\n        return true;\n      } else {\n        // contextClosing may be multiple keywords separated by ;\n        var closingKeywords = contextClosing.split(\";\");\n\n        for (var i in closingKeywords) {\n          if (text == closingKeywords[i]) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n    }\n\n    function isInsideScopeKind(ctx, scopekind) {\n      if (ctx == null) {\n        return false;\n      }\n\n      if (ctx.scopekind === scopekind) {\n        return true;\n      }\n\n      return isInsideScopeKind(ctx.prev, scopekind);\n    }\n\n    function buildElectricInputRegEx() {\n      // Reindentation should occur on any bracket char: {}()[]\n      // or on a match of any of the block closing keywords, at\n      // the end of a line\n      var allClosings = [];\n\n      for (var i in openClose) {\n        if (openClose[i]) {\n          var closings = openClose[i].split(\";\");\n\n          for (var j in closings) {\n            allClosings.push(closings[j]);\n          }\n        }\n      }\n\n      var re = new RegExp(\"[{}()\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n      return re;\n    } // Interface\n\n\n    return {\n      // Regex to force current line to reindent\n      electricInput: buildElectricInputRegEx(),\n      startState: function (basecolumn) {\n        var state = {\n          tokenize: null,\n          context: new Context((basecolumn || 0) - indentUnit, 0, \"top\", \"top\", false),\n          indented: 0,\n          compilerDirectiveIndented: 0,\n          startOfLine: true\n        };\n        if (hooks.startState) hooks.startState(state);\n        return state;\n      },\n      token: function (stream, state) {\n        var ctx = state.context;\n\n        if (stream.sol()) {\n          if (ctx.align == null) ctx.align = false;\n          state.indented = stream.indentation();\n          state.startOfLine = true;\n        }\n\n        if (hooks.token) {\n          // Call hook, with an optional return value of a style to override verilog styling.\n          var style = hooks.token(stream, state);\n\n          if (style !== undefined) {\n            return style;\n          }\n        }\n\n        if (stream.eatSpace()) return null;\n        curPunc = null;\n        curKeyword = null;\n        var style = (state.tokenize || tokenBase)(stream, state);\n\n        if (style == \"comment\" || style == \"meta\" || style == \"variable\") {\n          if ((curPunc === \"=\" || curPunc === \"<=\") && !isInsideScopeKind(ctx, \"assignment\")) {\n            // '<=' could be nonblocking assignment or lessthan-equals (which shouldn't cause indent)\n            //      Search through the context to see if we are already in an assignment.\n            // '=' could be inside port declaration with comma or ')' afterward, or inside for(;;) block.\n            pushContext(state, stream.column() + curPunc.length, \"assignment\", \"assignment\");\n            if (ctx.align == null) ctx.align = true;\n          }\n\n          return style;\n        }\n\n        if (ctx.align == null) ctx.align = true;\n        var isClosingAssignment = ctx.type == \"assignment\" && closingBracket.test(curPunc) && ctx.prev && ctx.prev.type === curPunc;\n\n        if (curPunc == ctx.type || isClosingAssignment) {\n          if (isClosingAssignment) {\n            ctx = popContext(state);\n          }\n\n          ctx = popContext(state);\n\n          if (curPunc == \")\") {\n            // Handle closing macros, assuming they could have a semicolon or begin/end block inside.\n            if (ctx && ctx.type === \"macro\") {\n              ctx = popContext(state);\n\n              while (ctx && (ctx.type == \"statement\" || ctx.type == \"assignment\")) ctx = popContext(state);\n            }\n          } else if (curPunc == \"}\") {\n            // Handle closing statements like constraint block: \"foreach () {}\" which\n            // do not have semicolon at end.\n            if (ctx && ctx.type === \"statement\") {\n              while (ctx && ctx.type == \"statement\") ctx = popContext(state);\n            }\n          }\n        } else if ((curPunc == \";\" || curPunc == \",\") && (ctx.type == \"statement\" || ctx.type == \"assignment\") || ctx.type && isClosing(curKeyword, ctx.type)) {\n          ctx = popContext(state);\n\n          while (ctx && (ctx.type == \"statement\" || ctx.type == \"assignment\")) ctx = popContext(state);\n        } else if (curPunc == \"{\") {\n          pushContext(state, stream.column(), \"}\");\n        } else if (curPunc == \"[\") {\n          pushContext(state, stream.column(), \"]\");\n        } else if (curPunc == \"(\") {\n          pushContext(state, stream.column(), \")\");\n        } else if (ctx && ctx.type == \"endcase\" && curPunc == \":\") {\n          pushContext(state, stream.column(), \"statement\", \"case\");\n        } else if (curPunc == \"newstatement\") {\n          pushContext(state, stream.column(), \"statement\", curKeyword);\n        } else if (curPunc == \"newblock\") {\n          if (curKeyword == \"function\" && ctx && (ctx.type == \"statement\" || ctx.type == \"endgroup\")) {// The 'function' keyword can appear in some other contexts where it actually does not\n            // indicate a function (import/export DPI and covergroup definitions).\n            // Do nothing in this case\n          } else if (curKeyword == \"task\" && ctx && ctx.type == \"statement\") {// Same thing for task\n          } else if (curKeyword == \"class\" && ctx && ctx.type == \"statement\") {// Same thing for class (e.g. typedef)\n          } else {\n            var close = openClose[curKeyword];\n            pushContext(state, stream.column(), close, curKeyword);\n          }\n        } else if (curPunc == \"newmacro\" || curKeyword && curKeyword.match(compilerDirectiveRegex)) {\n          if (curPunc == \"newmacro\") {\n            // Macros (especially if they have parenthesis) potentially have a semicolon\n            // or complete statement/block inside, and should be treated as such.\n            pushContext(state, stream.column(), \"macro\", \"macro\");\n          }\n\n          if (curKeyword.match(compilerDirectiveEndRegex)) {\n            state.compilerDirectiveIndented -= statementIndentUnit;\n          }\n\n          if (curKeyword.match(compilerDirectiveBeginRegex)) {\n            state.compilerDirectiveIndented += statementIndentUnit;\n          }\n        }\n\n        state.startOfLine = false;\n        return style;\n      },\n      indent: function (state, textAfter) {\n        if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;\n\n        if (hooks.indent) {\n          var fromHook = hooks.indent(state);\n          if (fromHook >= 0) return fromHook;\n        }\n\n        var ctx = state.context,\n            firstChar = textAfter && textAfter.charAt(0);\n        if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n        var closing = false;\n        var possibleClosing = textAfter.match(closingBracketOrWord);\n        if (possibleClosing) closing = isClosing(possibleClosing[0], ctx.type);\n\n        if (!compilerDirectivesUseRegularIndentation && textAfter.match(compilerDirectiveRegex)) {\n          if (textAfter.match(compilerDirectiveEndRegex)) {\n            return state.compilerDirectiveIndented - statementIndentUnit;\n          }\n\n          return state.compilerDirectiveIndented;\n        }\n\n        if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit);else if ((closingBracket.test(ctx.type) || ctx.type == \"assignment\") && ctx.align && !dontAlignCalls) return ctx.column + (closing ? 0 : 1);else if (ctx.type == \")\" && !closing) return ctx.indented + statementIndentUnit;else return ctx.indented + (closing ? 0 : indentUnit);\n      },\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\",\n      lineComment: \"//\",\n      fold: \"indent\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-verilog\", {\n    name: \"verilog\"\n  });\n  CodeMirror.defineMIME(\"text/x-systemverilog\", {\n    name: \"verilog\"\n  }); // TL-Verilog mode.\n  // See tl-x.org for language spec.\n  // See the mode in action at makerchip.com.\n  // Contact: steve.hoover@redwoodeda.com\n  // TLV Identifier prefixes.\n  // Note that sign is not treated separately, so \"+/-\" versions of numeric identifiers\n  // are included.\n\n  var tlvIdentifierStyle = {\n    \"|\": \"link\",\n    \">\": \"property\",\n    // Should condition this off for > TLV 1c.\n    \"$\": \"variable\",\n    \"$$\": \"variable\",\n    \"?$\": \"qualifier\",\n    \"?*\": \"qualifier\",\n    \"-\": \"hr\",\n    \"/\": \"property\",\n    \"/-\": \"property\",\n    \"@\": \"variable-3\",\n    \"@-\": \"variable-3\",\n    \"@++\": \"variable-3\",\n    \"@+=\": \"variable-3\",\n    \"@+=-\": \"variable-3\",\n    \"@--\": \"variable-3\",\n    \"@-=\": \"variable-3\",\n    \"%+\": \"tag\",\n    \"%-\": \"tag\",\n    \"%\": \"tag\",\n    \">>\": \"tag\",\n    \"<<\": \"tag\",\n    \"<>\": \"tag\",\n    \"#\": \"tag\",\n    // Need to choose a style for this.\n    \"^\": \"attribute\",\n    \"^^\": \"attribute\",\n    \"^!\": \"attribute\",\n    \"*\": \"variable-2\",\n    \"**\": \"variable-2\",\n    \"\\\\\": \"keyword\",\n    \"\\\"\": \"comment\"\n  }; // Lines starting with these characters define scope (result in indentation).\n\n  var tlvScopePrefixChars = {\n    \"/\": \"beh-hier\",\n    \">\": \"beh-hier\",\n    \"-\": \"phys-hier\",\n    \"|\": \"pipe\",\n    \"?\": \"when\",\n    \"@\": \"stage\",\n    \"\\\\\": \"keyword\"\n  };\n  var tlvIndentUnit = 3;\n  var tlvTrackStatements = false;\n  var tlvIdentMatch = /^([~!@#\\$%\\^&\\*-\\+=\\?\\/\\\\\\|'\"<>]+)([\\d\\w_]*)/; // Matches an identifier.\n  // Note that ':' is excluded, because of it's use in [:].\n\n  var tlvFirstLevelIndentMatch = /^[! ]  /;\n  var tlvLineIndentationMatch = /^[! ] */;\n  var tlvCommentMatch = /^\\/[\\/\\*]/; // Returns a style specific to the scope at the given indentation column.\n  // Type is one of: \"indent\", \"scope-ident\", \"before-scope-ident\".\n\n  function tlvScopeStyle(state, indentation, type) {\n    // Begin scope.\n    var depth = indentation / tlvIndentUnit; // TODO: Pass this in instead.\n\n    return \"tlv-\" + state.tlvIndentationStyle[depth] + \"-\" + type;\n  } // Return true if the next thing in the stream is an identifier with a mnemonic.\n\n\n  function tlvIdentNext(stream) {\n    var match;\n    return (match = stream.match(tlvIdentMatch, false)) && match[2].length > 0;\n  }\n\n  CodeMirror.defineMIME(\"text/x-tlv\", {\n    name: \"verilog\",\n    hooks: {\n      electricInput: false,\n      // Return undefined for verilog tokenizing, or style for TLV token (null not used).\n      // Standard CM styles are used for most formatting, but some TL-Verilog-specific highlighting\n      // can be enabled with the definition of cm-tlv-* styles, including highlighting for:\n      //   - M4 tokens\n      //   - TLV scope indentation\n      //   - Statement delimitation (enabled by tlvTrackStatements)\n      token: function (stream, state) {\n        var style = undefined;\n        var match; // Return value of pattern matches.\n        // Set highlighting mode based on code region (TLV or SV).\n\n        if (stream.sol() && !state.tlvInBlockComment) {\n          // Process region.\n          if (stream.peek() == '\\\\') {\n            style = \"def\";\n            stream.skipToEnd();\n\n            if (stream.string.match(/\\\\SV/)) {\n              state.tlvCodeActive = false;\n            } else if (stream.string.match(/\\\\TLV/)) {\n              state.tlvCodeActive = true;\n            }\n          } // Correct indentation in the face of a line prefix char.\n\n\n          if (state.tlvCodeActive && stream.pos == 0 && state.indented == 0 && (match = stream.match(tlvLineIndentationMatch, false))) {\n            state.indented = match[0].length;\n          } // Compute indentation state:\n          //   o Auto indentation on next line\n          //   o Indentation scope styles\n\n\n          var indented = state.indented;\n          var depth = indented / tlvIndentUnit;\n\n          if (depth <= state.tlvIndentationStyle.length) {\n            // not deeper than current scope\n            var blankline = stream.string.length == indented;\n            var chPos = depth * tlvIndentUnit;\n\n            if (chPos < stream.string.length) {\n              var bodyString = stream.string.slice(chPos);\n              var ch = bodyString[0];\n\n              if (tlvScopePrefixChars[ch] && (match = bodyString.match(tlvIdentMatch)) && tlvIdentifierStyle[match[1]]) {\n                // This line begins scope.\n                // Next line gets indented one level.\n                indented += tlvIndentUnit; // Style the next level of indentation (except non-region keyword identifiers,\n                //   which are statements themselves)\n\n                if (!(ch == \"\\\\\" && chPos > 0)) {\n                  state.tlvIndentationStyle[depth] = tlvScopePrefixChars[ch];\n\n                  if (tlvTrackStatements) {\n                    state.statementComment = false;\n                  }\n\n                  depth++;\n                }\n              }\n            } // Clear out deeper indentation levels unless line is blank.\n\n\n            if (!blankline) {\n              while (state.tlvIndentationStyle.length > depth) {\n                state.tlvIndentationStyle.pop();\n              }\n            }\n          } // Set next level of indentation.\n\n\n          state.tlvNextIndent = indented;\n        }\n\n        if (state.tlvCodeActive) {\n          // Highlight as TLV.\n          var beginStatement = false;\n\n          if (tlvTrackStatements) {\n            // This starts a statement if the position is at the scope level\n            // and we're not within a statement leading comment.\n            beginStatement = stream.peek() != \" \" && // not a space\n            style === undefined && // not a region identifier\n            !state.tlvInBlockComment && // not in block comment\n            //!stream.match(tlvCommentMatch, false) && // not comment start\n            stream.column() == state.tlvIndentationStyle.length * tlvIndentUnit; // at scope level\n\n            if (beginStatement) {\n              if (state.statementComment) {\n                // statement already started by comment\n                beginStatement = false;\n              }\n\n              state.statementComment = stream.match(tlvCommentMatch, false); // comment start\n            }\n          }\n\n          var match;\n\n          if (style !== undefined) {\n            // Region line.\n            style += \" \" + tlvScopeStyle(state, 0, \"scope-ident\");\n          } else if (stream.pos / tlvIndentUnit < state.tlvIndentationStyle.length && (match = stream.match(stream.sol() ? tlvFirstLevelIndentMatch : /^   /))) {\n            // Indentation\n            style = // make this style distinct from the previous one to prevent\n            // codemirror from combining spans\n            \"tlv-indent-\" + (stream.pos % 2 == 0 ? \"even\" : \"odd\") + // and style it\n            \" \" + tlvScopeStyle(state, stream.pos - tlvIndentUnit, \"indent\"); // Style the line prefix character.\n\n            if (match[0].charAt(0) == \"!\") {\n              style += \" tlv-alert-line-prefix\";\n            } // Place a class before a scope identifier.\n\n\n            if (tlvIdentNext(stream)) {\n              style += \" \" + tlvScopeStyle(state, stream.pos, \"before-scope-ident\");\n            }\n          } else if (state.tlvInBlockComment) {\n            // In a block comment.\n            if (stream.match(/^.*?\\*\\//)) {\n              // Exit block comment.\n              state.tlvInBlockComment = false;\n\n              if (tlvTrackStatements && !stream.eol()) {\n                // Anything after comment is assumed to be real statement content.\n                state.statementComment = false;\n              }\n            } else {\n              stream.skipToEnd();\n            }\n\n            style = \"comment\";\n          } else if ((match = stream.match(tlvCommentMatch)) && !state.tlvInBlockComment) {\n            // Start comment.\n            if (match[0] == \"//\") {\n              // Line comment.\n              stream.skipToEnd();\n            } else {\n              // Block comment.\n              state.tlvInBlockComment = true;\n            }\n\n            style = \"comment\";\n          } else if (match = stream.match(tlvIdentMatch)) {\n            // looks like an identifier (or identifier prefix)\n            var prefix = match[1];\n            var mnemonic = match[2];\n\n            if ( // is identifier prefix\n            tlvIdentifierStyle.hasOwnProperty(prefix) && ( // has mnemonic or we're at the end of the line (maybe it hasn't been typed yet)\n            mnemonic.length > 0 || stream.eol())) {\n              style = tlvIdentifierStyle[prefix];\n\n              if (stream.column() == state.indented) {\n                // Begin scope.\n                style += \" \" + tlvScopeStyle(state, stream.column(), \"scope-ident\");\n              }\n            } else {\n              // Just swallow one character and try again.\n              // This enables subsequent identifier match with preceding symbol character, which\n              //   is legal within a statement.  (E.g., !$reset).  It also enables detection of\n              //   comment start with preceding symbols.\n              stream.backUp(stream.current().length - 1);\n              style = \"tlv-default\";\n            }\n          } else if (stream.match(/^\\t+/)) {\n            // Highlight tabs, which are illegal.\n            style = \"tlv-tab\";\n          } else if (stream.match(/^[\\[\\]{}\\(\\);\\:]+/)) {\n            // [:], (), {}, ;.\n            style = \"meta\";\n          } else if (match = stream.match(/^[mM]4([\\+_])?[\\w\\d_]*/)) {\n            // m4 pre proc\n            style = match[1] == \"+\" ? \"tlv-m4-plus\" : \"tlv-m4\";\n          } else if (stream.match(/^ +/)) {\n            // Skip over spaces.\n            if (stream.eol()) {\n              // Trailing spaces.\n              style = \"error\";\n            } else {\n              // Non-trailing spaces.\n              style = \"tlv-default\";\n            }\n          } else if (stream.match(/^[\\w\\d_]+/)) {\n            // alpha-numeric token.\n            style = \"number\";\n          } else {\n            // Eat the next char w/ no formatting.\n            stream.next();\n            style = \"tlv-default\";\n          }\n\n          if (beginStatement) {\n            style += \" tlv-statement\";\n          }\n        } else {\n          if (stream.match(/^[mM]4([\\w\\d_]*)/)) {\n            // m4 pre proc\n            style = \"tlv-m4\";\n          }\n        }\n\n        return style;\n      },\n      indent: function (state) {\n        return state.tlvCodeActive == true ? state.tlvNextIndent : -1;\n      },\n      startState: function (state) {\n        state.tlvIndentationStyle = []; // Styles to use for each level of indentation.\n\n        state.tlvCodeActive = true; // True when we're in a TLV region (and at beginning of file).\n\n        state.tlvNextIndent = -1; // The number of spaces to autoindent the next line if tlvCodeActive.\n\n        state.tlvInBlockComment = false; // True inside /**/ comment.\n\n        if (tlvTrackStatements) {\n          state.statementComment = false; // True inside a statement's header comment.\n        }\n      }\n    }\n  });\n});","map":{"version":3,"sources":["D:/Facultate/Licenta/remote-debugging-app/remote-debugging-app/frontend/node_modules/codemirror/mode/verilog/verilog.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","config","parserConfig","indentUnit","statementIndentUnit","dontAlignCalls","compilerDirectivesUseRegularIndentation","noIndentKeywords","multiLineStrings","hooks","words","str","obj","split","i","length","keywords","isOperatorChar","isBracketChar","unsignedNumber","decimalLiteral","binaryLiteral","octLiteral","hexLiteral","realLiteral","closingBracketOrWord","closingBracket","compilerDirectiveRegex","RegExp","compilerDirectiveBeginRegex","compilerDirectiveEndRegex","curPunc","curKeyword","blockKeywords","openClose","keyword","undefined","statementKeywords","tokenBase","stream","state","ch","peek","style","test","next","eatWhile","cur","current","startsWith","endsWith","keywordClose","substr","eatSpace","withSpace","backUp","tokenize","tokenString","eat","tokenComment","skipToEnd","match","quote","escaped","end","maybeEnd","Context","indented","column","type","scopekind","align","prev","pushContext","col","indent","c","context","popContext","t","isClosing","text","contextClosing","closingKeywords","isInsideScopeKind","ctx","buildElectricInputRegEx","allClosings","closings","j","push","re","join","electricInput","startState","basecolumn","compilerDirectiveIndented","startOfLine","token","sol","indentation","isClosingAssignment","close","textAfter","Pass","fromHook","firstChar","charAt","closing","possibleClosing","blockCommentStart","blockCommentEnd","lineComment","fold","defineMIME","name","tlvIdentifierStyle","tlvScopePrefixChars","tlvIndentUnit","tlvTrackStatements","tlvIdentMatch","tlvFirstLevelIndentMatch","tlvLineIndentationMatch","tlvCommentMatch","tlvScopeStyle","depth","tlvIndentationStyle","tlvIdentNext","tlvInBlockComment","string","tlvCodeActive","pos","blankline","chPos","bodyString","slice","statementComment","pop","tlvNextIndent","beginStatement","eol","prefix","mnemonic","hasOwnProperty"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"verilog\", function(config, parserConfig) {\n\n  var indentUnit = config.indentUnit,\n      statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,\n      dontAlignCalls = parserConfig.dontAlignCalls,\n      // compilerDirectivesUseRegularIndentation - If set, Compiler directive\n      // indentation follows the same rules as everything else. Otherwise if\n      // false, compiler directives will track their own indentation.\n      // For example, `ifdef nested inside another `ifndef will be indented,\n      // but a `ifdef inside a function block may not be indented.\n      compilerDirectivesUseRegularIndentation = parserConfig.compilerDirectivesUseRegularIndentation,\n      noIndentKeywords = parserConfig.noIndentKeywords || [],\n      multiLineStrings = parserConfig.multiLineStrings,\n      hooks = parserConfig.hooks || {};\n\n  function words(str) {\n    var obj = {}, words = str.split(\" \");\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n    return obj;\n  }\n\n  /**\n   * Keywords from IEEE 1800-2012\n   */\n  var keywords = words(\n    \"accept_on alias always always_comb always_ff always_latch and assert assign assume automatic before begin bind \" +\n    \"bins binsof bit break buf bufif0 bufif1 byte case casex casez cell chandle checker class clocking cmos config \" +\n    \"const constraint context continue cover covergroup coverpoint cross deassign default defparam design disable \" +\n    \"dist do edge else end endcase endchecker endclass endclocking endconfig endfunction endgenerate endgroup \" +\n    \"endinterface endmodule endpackage endprimitive endprogram endproperty endspecify endsequence endtable endtask \" +\n    \"enum event eventually expect export extends extern final first_match for force foreach forever fork forkjoin \" +\n    \"function generate genvar global highz0 highz1 if iff ifnone ignore_bins illegal_bins implements implies import \" +\n    \"incdir include initial inout input inside instance int integer interconnect interface intersect join join_any \" +\n    \"join_none large let liblist library local localparam logic longint macromodule matches medium modport module \" +\n    \"nand negedge nettype new nexttime nmos nor noshowcancelled not notif0 notif1 null or output package packed \" +\n    \"parameter pmos posedge primitive priority program property protected pull0 pull1 pulldown pullup \" +\n    \"pulsestyle_ondetect pulsestyle_onevent pure rand randc randcase randsequence rcmos real realtime ref reg \" +\n    \"reject_on release repeat restrict return rnmos rpmos rtran rtranif0 rtranif1 s_always s_eventually s_nexttime \" +\n    \"s_until s_until_with scalared sequence shortint shortreal showcancelled signed small soft solve specify \" +\n    \"specparam static string strong strong0 strong1 struct super supply0 supply1 sync_accept_on sync_reject_on \" +\n    \"table tagged task this throughout time timeprecision timeunit tran tranif0 tranif1 tri tri0 tri1 triand trior \" +\n    \"trireg type typedef union unique unique0 unsigned until until_with untyped use uwire var vectored virtual void \" +\n    \"wait wait_order wand weak weak0 weak1 while wildcard wire with within wor xnor xor\");\n\n  /** Operators from IEEE 1800-2012\n     unary_operator ::=\n       + | - | ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n     binary_operator ::=\n       + | - | * | / | % | == | != | === | !== | ==? | !=? | && | || | **\n       | < | <= | > | >= | & | | | ^ | ^~ | ~^ | >> | << | >>> | <<<\n       | -> | <->\n     inc_or_dec_operator ::= ++ | --\n     unary_module_path_operator ::=\n       ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n     binary_module_path_operator ::=\n       == | != | && | || | & | | | ^ | ^~ | ~^\n  */\n  var isOperatorChar = /[\\+\\-\\*\\/!~&|^%=?:<>]/;\n  var isBracketChar = /[\\[\\]{}()]/;\n\n  var unsignedNumber = /\\d[0-9_]*/;\n  var decimalLiteral = /\\d*\\s*'s?d\\s*\\d[0-9_]*/i;\n  var binaryLiteral = /\\d*\\s*'s?b\\s*[xz01][xz01_]*/i;\n  var octLiteral = /\\d*\\s*'s?o\\s*[xz0-7][xz0-7_]*/i;\n  var hexLiteral = /\\d*\\s*'s?h\\s*[0-9a-fxz?][0-9a-fxz?_]*/i;\n  var realLiteral = /(\\d[\\d_]*(\\.\\d[\\d_]*)?E-?[\\d_]+)|(\\d[\\d_]*\\.\\d[\\d_]*)/i;\n\n  var closingBracketOrWord = /^((`?\\w+)|[)}\\]])/;\n  var closingBracket = /[)}\\]]/;\n  var compilerDirectiveRegex      = new RegExp(\n    \"^(`(?:ifdef|ifndef|elsif|else|endif|undef|undefineall|define|include|begin_keywords|celldefine|default|\" +\n    \"nettype|end_keywords|endcelldefine|line|nounconnected_drive|pragma|resetall|timescale|unconnected_drive))\\\\b\");\n  var compilerDirectiveBeginRegex = /^(`(?:ifdef|ifndef|elsif|else))\\b/;\n  var compilerDirectiveEndRegex   = /^(`(?:elsif|else|endif))\\b/;\n\n  var curPunc;\n  var curKeyword;\n\n  // Block openings which are closed by a matching keyword in the form of (\"end\" + keyword)\n  // E.g. \"task\" => \"endtask\"\n  var blockKeywords = words(\n    \"case checker class clocking config function generate interface module package \" +\n    \"primitive program property specify sequence table task\"\n  );\n\n  // Opening/closing pairs\n  var openClose = {};\n  for (var keyword in blockKeywords) {\n    openClose[keyword] = \"end\" + keyword;\n  }\n  openClose[\"begin\"] = \"end\";\n  openClose[\"casex\"] = \"endcase\";\n  openClose[\"casez\"] = \"endcase\";\n  openClose[\"do\"   ] = \"while\";\n  openClose[\"fork\" ] = \"join;join_any;join_none\";\n  openClose[\"covergroup\"] = \"endgroup\";\n  openClose[\"macro_begin\"] = \"macro_end\";\n\n  for (var i in noIndentKeywords) {\n    var keyword = noIndentKeywords[i];\n    if (openClose[keyword]) {\n      openClose[keyword] = undefined;\n    }\n  }\n\n  // Keywords which open statements that are ended with a semi-colon\n  var statementKeywords = words(\"always always_comb always_ff always_latch assert assign assume else export for foreach forever if import initial repeat while extern typedef\");\n\n  function tokenBase(stream, state) {\n    var ch = stream.peek(), style;\n    if (hooks[ch] && (style = hooks[ch](stream, state)) != false) return style;\n    if (hooks.tokenBase && (style = hooks.tokenBase(stream, state)) != false)\n      return style;\n\n    if (/[,;:\\.]/.test(ch)) {\n      curPunc = stream.next();\n      return null;\n    }\n    if (isBracketChar.test(ch)) {\n      curPunc = stream.next();\n      return \"bracket\";\n    }\n    // Macros (tick-defines)\n    if (ch == '`') {\n      stream.next();\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        var cur = stream.current();\n        curKeyword = cur;\n        // Macros that end in _begin, are start of block and end with _end\n        if (cur.startsWith(\"`uvm_\") && cur.endsWith(\"_begin\")) {\n          var keywordClose = curKeyword.substr(0,curKeyword.length - 5) + \"end\";\n          openClose[cur] = keywordClose;\n          curPunc = \"newblock\";\n        } else {\n          stream.eatSpace();\n          if (stream.peek() == '(') {\n            // Check if this is a block\n            curPunc = \"newmacro\";\n          }\n          var withSpace = stream.current();\n          // Move the stream back before the spaces\n          stream.backUp(withSpace.length - cur.length);\n        }\n        return \"def\";\n      } else {\n        return null;\n      }\n    }\n    // System calls\n    if (ch == '$') {\n      stream.next();\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        return \"meta\";\n      } else {\n        return null;\n      }\n    }\n    // Time literals\n    if (ch == '#') {\n      stream.next();\n      stream.eatWhile(/[\\d_.]/);\n      return \"def\";\n    }\n    // Event\n    if (ch == '@') {\n      stream.next();\n      stream.eatWhile(/[@]/);\n      return \"def\";\n    }\n    // Strings\n    if (ch == '\"') {\n      stream.next();\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    }\n    // Comments\n    if (ch == \"/\") {\n      stream.next();\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      }\n      if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n      stream.backUp(1);\n    }\n\n    // Numeric literals\n    if (stream.match(realLiteral) ||\n        stream.match(decimalLiteral) ||\n        stream.match(binaryLiteral) ||\n        stream.match(octLiteral) ||\n        stream.match(hexLiteral) ||\n        stream.match(unsignedNumber) ||\n        stream.match(realLiteral)) {\n      return \"number\";\n    }\n\n    // Operators\n    if (stream.eatWhile(isOperatorChar)) {\n      curPunc = stream.current();\n      return \"meta\";\n    }\n\n    // Keywords / plain variables\n    if (stream.eatWhile(/[\\w\\$_]/)) {\n      var cur = stream.current();\n      if (keywords[cur]) {\n        if (openClose[cur]) {\n          curPunc = \"newblock\";\n          if (cur === \"fork\") {\n            // Fork can be a statement instead of block in cases of:\n            // \"disable fork;\" and \"wait fork;\" (trailing semicolon)\n            stream.eatSpace()\n            if (stream.peek() == ';') {\n              curPunc = \"newstatement\";\n            }\n            stream.backUp(stream.current().length - cur.length);\n          }\n        }\n        if (statementKeywords[cur]) {\n          curPunc = \"newstatement\";\n        }\n        curKeyword = cur;\n        return \"keyword\";\n      }\n      return \"variable\";\n    }\n\n    stream.next();\n    return null;\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next, end = false;\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) {end = true; break;}\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (end || !(escaped || multiLineStrings))\n        state.tokenize = tokenBase;\n      return \"string\";\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return \"comment\";\n  }\n\n  function Context(indented, column, type, scopekind, align, prev) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.scopekind = scopekind;\n    this.align = align;\n    this.prev = prev;\n  }\n  function pushContext(state, col, type, scopekind) {\n    var indent = state.indented;\n    var c = new Context(indent, col, type, scopekind ? scopekind : \"\", null, state.context);\n    return state.context = c;\n  }\n  function popContext(state) {\n    var t = state.context.type;\n    if (t == \")\" || t == \"]\" || t == \"}\") {\n      state.indented = state.context.indented;\n    }\n    return state.context = state.context.prev;\n  }\n\n  function isClosing(text, contextClosing) {\n    if (text == contextClosing) {\n      return true;\n    } else {\n      // contextClosing may be multiple keywords separated by ;\n      var closingKeywords = contextClosing.split(\";\");\n      for (var i in closingKeywords) {\n        if (text == closingKeywords[i]) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  function isInsideScopeKind(ctx, scopekind) {\n    if (ctx == null) {\n      return false;\n    }\n    if (ctx.scopekind === scopekind) {\n      return true;\n    }\n    return isInsideScopeKind(ctx.prev, scopekind);\n  }\n\n  function buildElectricInputRegEx() {\n    // Reindentation should occur on any bracket char: {}()[]\n    // or on a match of any of the block closing keywords, at\n    // the end of a line\n    var allClosings = [];\n    for (var i in openClose) {\n      if (openClose[i]) {\n        var closings = openClose[i].split(\";\");\n        for (var j in closings) {\n          allClosings.push(closings[j]);\n        }\n      }\n    }\n    var re = new RegExp(\"[{}()\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n    return re;\n  }\n\n  // Interface\n  return {\n\n    // Regex to force current line to reindent\n    electricInput: buildElectricInputRegEx(),\n\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: null,\n        context: new Context((basecolumn || 0) - indentUnit, 0, \"top\", \"top\", false),\n        indented: 0,\n        compilerDirectiveIndented: 0,\n        startOfLine: true\n      };\n      if (hooks.startState) hooks.startState(state);\n      return state;\n    },\n\n    token: function(stream, state) {\n      var ctx = state.context;\n      if (stream.sol()) {\n        if (ctx.align == null) ctx.align = false;\n        state.indented = stream.indentation();\n        state.startOfLine = true;\n      }\n      if (hooks.token) {\n        // Call hook, with an optional return value of a style to override verilog styling.\n        var style = hooks.token(stream, state);\n        if (style !== undefined) {\n          return style;\n        }\n      }\n      if (stream.eatSpace()) return null;\n      curPunc = null;\n      curKeyword = null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style == \"comment\" || style == \"meta\" || style == \"variable\") {\n        if (((curPunc === \"=\") || (curPunc === \"<=\")) && !isInsideScopeKind(ctx, \"assignment\")) {\n          // '<=' could be nonblocking assignment or lessthan-equals (which shouldn't cause indent)\n          //      Search through the context to see if we are already in an assignment.\n          // '=' could be inside port declaration with comma or ')' afterward, or inside for(;;) block.\n          pushContext(state, stream.column() + curPunc.length, \"assignment\", \"assignment\");\n          if (ctx.align == null) ctx.align = true;\n        }\n        return style;\n      }\n      if (ctx.align == null) ctx.align = true;\n\n      var isClosingAssignment = ctx.type == \"assignment\" &&\n        closingBracket.test(curPunc) && ctx.prev && ctx.prev.type === curPunc;\n      if (curPunc == ctx.type || isClosingAssignment) {\n        if (isClosingAssignment) {\n          ctx = popContext(state);\n        }\n        ctx = popContext(state);\n        if (curPunc == \")\") {\n          // Handle closing macros, assuming they could have a semicolon or begin/end block inside.\n          if (ctx && (ctx.type === \"macro\")) {\n            ctx = popContext(state);\n            while (ctx && (ctx.type == \"statement\" || ctx.type == \"assignment\")) ctx = popContext(state);\n          }\n        } else if (curPunc == \"}\") {\n          // Handle closing statements like constraint block: \"foreach () {}\" which\n          // do not have semicolon at end.\n          if (ctx && (ctx.type === \"statement\")) {\n            while (ctx && (ctx.type == \"statement\")) ctx = popContext(state);\n          }\n        }\n      } else if (((curPunc == \";\" || curPunc == \",\") && (ctx.type == \"statement\" || ctx.type == \"assignment\")) ||\n               (ctx.type && isClosing(curKeyword, ctx.type))) {\n        ctx = popContext(state);\n        while (ctx && (ctx.type == \"statement\" || ctx.type == \"assignment\")) ctx = popContext(state);\n      } else if (curPunc == \"{\") {\n        pushContext(state, stream.column(), \"}\");\n      } else if (curPunc == \"[\") {\n        pushContext(state, stream.column(), \"]\");\n      } else if (curPunc == \"(\") {\n        pushContext(state, stream.column(), \")\");\n      } else if (ctx && ctx.type == \"endcase\" && curPunc == \":\") {\n        pushContext(state, stream.column(), \"statement\", \"case\");\n      } else if (curPunc == \"newstatement\") {\n        pushContext(state, stream.column(), \"statement\", curKeyword);\n      } else if (curPunc == \"newblock\") {\n        if (curKeyword == \"function\" && ctx && (ctx.type == \"statement\" || ctx.type == \"endgroup\")) {\n          // The 'function' keyword can appear in some other contexts where it actually does not\n          // indicate a function (import/export DPI and covergroup definitions).\n          // Do nothing in this case\n        } else if (curKeyword == \"task\" && ctx && ctx.type == \"statement\") {\n          // Same thing for task\n        } else if (curKeyword == \"class\" && ctx && ctx.type == \"statement\") {\n          // Same thing for class (e.g. typedef)\n        } else {\n          var close = openClose[curKeyword];\n          pushContext(state, stream.column(), close, curKeyword);\n        }\n      } else if (curPunc == \"newmacro\" || (curKeyword && curKeyword.match(compilerDirectiveRegex))) {\n        if (curPunc == \"newmacro\") {\n          // Macros (especially if they have parenthesis) potentially have a semicolon\n          // or complete statement/block inside, and should be treated as such.\n          pushContext(state, stream.column(), \"macro\", \"macro\");\n        }\n        if (curKeyword.match(compilerDirectiveEndRegex)) {\n          state.compilerDirectiveIndented -= statementIndentUnit;\n        }\n        if (curKeyword.match(compilerDirectiveBeginRegex)) {\n          state.compilerDirectiveIndented += statementIndentUnit;\n        }\n      }\n\n      state.startOfLine = false;\n      return style;\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;\n      if (hooks.indent) {\n        var fromHook = hooks.indent(state);\n        if (fromHook >= 0) return fromHook;\n      }\n      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);\n      if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n      var closing = false;\n      var possibleClosing = textAfter.match(closingBracketOrWord);\n      if (possibleClosing)\n        closing = isClosing(possibleClosing[0], ctx.type);\n      if (!compilerDirectivesUseRegularIndentation && textAfter.match(compilerDirectiveRegex)) {\n        if (textAfter.match(compilerDirectiveEndRegex)) {\n          return state.compilerDirectiveIndented - statementIndentUnit;\n        }\n        return state.compilerDirectiveIndented;\n      }\n      if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit);\n      else if ((closingBracket.test(ctx.type) || ctx.type == \"assignment\")\n        && ctx.align && !dontAlignCalls) return ctx.column + (closing ? 0 : 1);\n      else if (ctx.type == \")\" && !closing) return ctx.indented + statementIndentUnit;\n      else return ctx.indented + (closing ? 0 : indentUnit);\n    },\n\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\",\n    lineComment: \"//\",\n    fold: \"indent\"\n  };\n});\n\n  CodeMirror.defineMIME(\"text/x-verilog\", {\n    name: \"verilog\"\n  });\n\n  CodeMirror.defineMIME(\"text/x-systemverilog\", {\n    name: \"verilog\"\n  });\n\n\n\n  // TL-Verilog mode.\n  // See tl-x.org for language spec.\n  // See the mode in action at makerchip.com.\n  // Contact: steve.hoover@redwoodeda.com\n\n  // TLV Identifier prefixes.\n  // Note that sign is not treated separately, so \"+/-\" versions of numeric identifiers\n  // are included.\n  var tlvIdentifierStyle = {\n    \"|\": \"link\",\n    \">\": \"property\",  // Should condition this off for > TLV 1c.\n    \"$\": \"variable\",\n    \"$$\": \"variable\",\n    \"?$\": \"qualifier\",\n    \"?*\": \"qualifier\",\n    \"-\": \"hr\",\n    \"/\": \"property\",\n    \"/-\": \"property\",\n    \"@\": \"variable-3\",\n    \"@-\": \"variable-3\",\n    \"@++\": \"variable-3\",\n    \"@+=\": \"variable-3\",\n    \"@+=-\": \"variable-3\",\n    \"@--\": \"variable-3\",\n    \"@-=\": \"variable-3\",\n    \"%+\": \"tag\",\n    \"%-\": \"tag\",\n    \"%\": \"tag\",\n    \">>\": \"tag\",\n    \"<<\": \"tag\",\n    \"<>\": \"tag\",\n    \"#\": \"tag\",  // Need to choose a style for this.\n    \"^\": \"attribute\",\n    \"^^\": \"attribute\",\n    \"^!\": \"attribute\",\n    \"*\": \"variable-2\",\n    \"**\": \"variable-2\",\n    \"\\\\\": \"keyword\",\n    \"\\\"\": \"comment\"\n  };\n\n  // Lines starting with these characters define scope (result in indentation).\n  var tlvScopePrefixChars = {\n    \"/\": \"beh-hier\",\n    \">\": \"beh-hier\",\n    \"-\": \"phys-hier\",\n    \"|\": \"pipe\",\n    \"?\": \"when\",\n    \"@\": \"stage\",\n    \"\\\\\": \"keyword\"\n  };\n  var tlvIndentUnit = 3;\n  var tlvTrackStatements = false;\n  var tlvIdentMatch = /^([~!@#\\$%\\^&\\*-\\+=\\?\\/\\\\\\|'\"<>]+)([\\d\\w_]*)/;  // Matches an identifier.\n  // Note that ':' is excluded, because of it's use in [:].\n  var tlvFirstLevelIndentMatch = /^[! ]  /;\n  var tlvLineIndentationMatch = /^[! ] */;\n  var tlvCommentMatch = /^\\/[\\/\\*]/;\n\n\n  // Returns a style specific to the scope at the given indentation column.\n  // Type is one of: \"indent\", \"scope-ident\", \"before-scope-ident\".\n  function tlvScopeStyle(state, indentation, type) {\n    // Begin scope.\n    var depth = indentation / tlvIndentUnit;  // TODO: Pass this in instead.\n    return \"tlv-\" + state.tlvIndentationStyle[depth] + \"-\" + type;\n  }\n\n  // Return true if the next thing in the stream is an identifier with a mnemonic.\n  function tlvIdentNext(stream) {\n    var match;\n    return (match = stream.match(tlvIdentMatch, false)) && match[2].length > 0;\n  }\n\n  CodeMirror.defineMIME(\"text/x-tlv\", {\n    name: \"verilog\",\n\n    hooks: {\n\n      electricInput: false,\n\n\n      // Return undefined for verilog tokenizing, or style for TLV token (null not used).\n      // Standard CM styles are used for most formatting, but some TL-Verilog-specific highlighting\n      // can be enabled with the definition of cm-tlv-* styles, including highlighting for:\n      //   - M4 tokens\n      //   - TLV scope indentation\n      //   - Statement delimitation (enabled by tlvTrackStatements)\n      token: function(stream, state) {\n        var style = undefined;\n        var match;  // Return value of pattern matches.\n\n        // Set highlighting mode based on code region (TLV or SV).\n        if (stream.sol() && ! state.tlvInBlockComment) {\n          // Process region.\n          if (stream.peek() == '\\\\') {\n            style = \"def\";\n            stream.skipToEnd();\n            if (stream.string.match(/\\\\SV/)) {\n              state.tlvCodeActive = false;\n            } else if (stream.string.match(/\\\\TLV/)){\n              state.tlvCodeActive = true;\n            }\n          }\n          // Correct indentation in the face of a line prefix char.\n          if (state.tlvCodeActive && stream.pos == 0 &&\n              (state.indented == 0) && (match = stream.match(tlvLineIndentationMatch, false))) {\n            state.indented = match[0].length;\n          }\n\n          // Compute indentation state:\n          //   o Auto indentation on next line\n          //   o Indentation scope styles\n          var indented = state.indented;\n          var depth = indented / tlvIndentUnit;\n          if (depth <= state.tlvIndentationStyle.length) {\n            // not deeper than current scope\n\n            var blankline = stream.string.length == indented;\n            var chPos = depth * tlvIndentUnit;\n            if (chPos < stream.string.length) {\n              var bodyString = stream.string.slice(chPos);\n              var ch = bodyString[0];\n              if (tlvScopePrefixChars[ch] && ((match = bodyString.match(tlvIdentMatch)) &&\n                  tlvIdentifierStyle[match[1]])) {\n                // This line begins scope.\n                // Next line gets indented one level.\n                indented += tlvIndentUnit;\n                // Style the next level of indentation (except non-region keyword identifiers,\n                //   which are statements themselves)\n                if (!(ch == \"\\\\\" && chPos > 0)) {\n                  state.tlvIndentationStyle[depth] = tlvScopePrefixChars[ch];\n                  if (tlvTrackStatements) {state.statementComment = false;}\n                  depth++;\n                }\n              }\n            }\n            // Clear out deeper indentation levels unless line is blank.\n            if (!blankline) {\n              while (state.tlvIndentationStyle.length > depth) {\n                state.tlvIndentationStyle.pop();\n              }\n            }\n          }\n          // Set next level of indentation.\n          state.tlvNextIndent = indented;\n        }\n\n        if (state.tlvCodeActive) {\n          // Highlight as TLV.\n\n          var beginStatement = false;\n          if (tlvTrackStatements) {\n            // This starts a statement if the position is at the scope level\n            // and we're not within a statement leading comment.\n            beginStatement =\n                   (stream.peek() != \" \") &&   // not a space\n                   (style === undefined) &&    // not a region identifier\n                   !state.tlvInBlockComment && // not in block comment\n                   //!stream.match(tlvCommentMatch, false) && // not comment start\n                   (stream.column() == state.tlvIndentationStyle.length * tlvIndentUnit);  // at scope level\n            if (beginStatement) {\n              if (state.statementComment) {\n                // statement already started by comment\n                beginStatement = false;\n              }\n              state.statementComment =\n                   stream.match(tlvCommentMatch, false); // comment start\n            }\n          }\n\n          var match;\n          if (style !== undefined) {\n            // Region line.\n            style += \" \" + tlvScopeStyle(state, 0, \"scope-ident\")\n          } else if (((stream.pos / tlvIndentUnit) < state.tlvIndentationStyle.length) &&\n                     (match = stream.match(stream.sol() ? tlvFirstLevelIndentMatch : /^   /))) {\n            // Indentation\n            style = // make this style distinct from the previous one to prevent\n                    // codemirror from combining spans\n                    \"tlv-indent-\" + (((stream.pos % 2) == 0) ? \"even\" : \"odd\") +\n                    // and style it\n                    \" \" + tlvScopeStyle(state, stream.pos - tlvIndentUnit, \"indent\");\n            // Style the line prefix character.\n            if (match[0].charAt(0) == \"!\") {\n              style += \" tlv-alert-line-prefix\";\n            }\n            // Place a class before a scope identifier.\n            if (tlvIdentNext(stream)) {\n              style += \" \" + tlvScopeStyle(state, stream.pos, \"before-scope-ident\");\n            }\n          } else if (state.tlvInBlockComment) {\n            // In a block comment.\n            if (stream.match(/^.*?\\*\\//)) {\n              // Exit block comment.\n              state.tlvInBlockComment = false;\n              if (tlvTrackStatements && !stream.eol()) {\n                // Anything after comment is assumed to be real statement content.\n                state.statementComment = false;\n              }\n            } else {\n              stream.skipToEnd();\n            }\n            style = \"comment\";\n          } else if ((match = stream.match(tlvCommentMatch)) && !state.tlvInBlockComment) {\n            // Start comment.\n            if (match[0] == \"//\") {\n              // Line comment.\n              stream.skipToEnd();\n            } else {\n              // Block comment.\n              state.tlvInBlockComment = true;\n            }\n            style = \"comment\";\n          } else if (match = stream.match(tlvIdentMatch)) {\n            // looks like an identifier (or identifier prefix)\n            var prefix = match[1];\n            var mnemonic = match[2];\n            if (// is identifier prefix\n                tlvIdentifierStyle.hasOwnProperty(prefix) &&\n                // has mnemonic or we're at the end of the line (maybe it hasn't been typed yet)\n                (mnemonic.length > 0 || stream.eol())) {\n              style = tlvIdentifierStyle[prefix];\n              if (stream.column() == state.indented) {\n                // Begin scope.\n                style += \" \" + tlvScopeStyle(state, stream.column(), \"scope-ident\")\n              }\n            } else {\n              // Just swallow one character and try again.\n              // This enables subsequent identifier match with preceding symbol character, which\n              //   is legal within a statement.  (E.g., !$reset).  It also enables detection of\n              //   comment start with preceding symbols.\n              stream.backUp(stream.current().length - 1);\n              style = \"tlv-default\";\n            }\n          } else if (stream.match(/^\\t+/)) {\n            // Highlight tabs, which are illegal.\n            style = \"tlv-tab\";\n          } else if (stream.match(/^[\\[\\]{}\\(\\);\\:]+/)) {\n            // [:], (), {}, ;.\n            style = \"meta\";\n          } else if (match = stream.match(/^[mM]4([\\+_])?[\\w\\d_]*/)) {\n            // m4 pre proc\n            style = (match[1] == \"+\") ? \"tlv-m4-plus\" : \"tlv-m4\";\n          } else if (stream.match(/^ +/)){\n            // Skip over spaces.\n            if (stream.eol()) {\n              // Trailing spaces.\n              style = \"error\";\n            } else {\n              // Non-trailing spaces.\n              style = \"tlv-default\";\n            }\n          } else if (stream.match(/^[\\w\\d_]+/)) {\n            // alpha-numeric token.\n            style = \"number\";\n          } else {\n            // Eat the next char w/ no formatting.\n            stream.next();\n            style = \"tlv-default\";\n          }\n          if (beginStatement) {\n            style += \" tlv-statement\";\n          }\n        } else {\n          if (stream.match(/^[mM]4([\\w\\d_]*)/)) {\n            // m4 pre proc\n            style = \"tlv-m4\";\n          }\n        }\n        return style;\n      },\n\n      indent: function(state) {\n        return (state.tlvCodeActive == true) ? state.tlvNextIndent : -1;\n      },\n\n      startState: function(state) {\n        state.tlvIndentationStyle = [];  // Styles to use for each level of indentation.\n        state.tlvCodeActive = true;  // True when we're in a TLV region (and at beginning of file).\n        state.tlvNextIndent = -1;    // The number of spaces to autoindent the next line if tlvCodeActive.\n        state.tlvInBlockComment = false;  // True inside /**/ comment.\n        if (tlvTrackStatements) {\n          state.statementComment = false;  // True inside a statement's header comment.\n        }\n      }\n\n    }\n  });\n});\n"]},"metadata":{},"sourceType":"script"}